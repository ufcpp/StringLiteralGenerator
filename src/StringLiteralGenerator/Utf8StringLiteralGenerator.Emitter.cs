using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace StringLiteralGenerator;

public partial class Utf8StringLiteralGenerator
{
    private static void Emit(SourceProductionContext context, ImmutableArray<BinaryLiteralMethod> methods)
    {
        var buffer = new StringBuilder();

        var group = methods.GroupBy(x => x.Type, x => x.Method);

        foreach (var g in group)
        {
            var containingType = g.Key;
            var generatedSource = Generate(containingType, g, buffer);
            var filename = GetFilename(containingType, buffer);
            context.AddSource(filename, SourceText.From(generatedSource, Encoding.UTF8));
        }
    }

    private static string GetFilename(TypeInfo type, StringBuilder buffer)
    {
        buffer.Clear();

        if (type.Namespace is { } ns)
        {
            buffer.Append(ns.Replace('.', '_'));
            buffer.Append('_');
        }
        buffer.Append(type.Name);
        buffer.Append("_utf8literal.cs");

        return buffer.ToString();
    }

    private static string Generate(TypeInfo type, IEnumerable<MethodInfo> methods, StringBuilder buffer)
    {
        var (ns, name, isValueType) = type;

        buffer.Clear();
        buffer.Append(@"// <auto-generated />
");

        if (ns is not null)
        {
            buffer.Append(@"namespace ");
            buffer.Append(ns);
            buffer.Append(@"
{
");
        }
        buffer.Append(@"partial ");
        if (isValueType)
        {
            buffer.Append("struct ");
        }
        else
        {
            buffer.Append("class ");
        }

        buffer.Append(name);
        buffer.Append(@"
{
");
        foreach (var (methodName, accessibility, value, format) in methods)
        {
            buffer.Append("    ");
            buffer.Append(AccessibilityText(accessibility));
            buffer.Append(" static partial System.ReadOnlySpan<byte> ");
            buffer.Append(methodName);
            buffer.Append("() => new byte[] {");

            var bytes = format switch
            {
                LiteralFormat.Utf8 => Encoding.UTF8.GetBytes(value),
                LiteralFormat.Hex => ToHex(value),
                _ => throw new NotSupportedException(),
            };

            foreach (var b in bytes)
            {
                buffer.Append(b);
                buffer.Append(", ");
            }

            buffer.Append(@"};
");
        }

        buffer.Append(@"}
");
        if (ns is not null)
        {
            buffer.Append(@"}
");
        }

        return buffer.ToString();
    }

    //todo: Report an analyzer error for mul-formed string.
    private static byte[] ToHex(string text)
    {
        static byte hex(char c) => c switch
        {
            >= '0' and <= '9' => (byte)(c - '0'),
            >= 'a' and <= 'f' => (byte)(c - 'a' + 10),
            >= 'A' and <= 'F' => (byte)(c - 'A' + 10),
            _ => 0, // should throw?
        };

        var bytes = new byte[text.Length / 2];
        for (int i = 0; i < text.Length; i += 2)
        {
            bytes[i / 2] = (byte)((hex(text[i]) << 4) | hex(text[i + 1]));
        }

        return bytes;
    }

    private static string AccessibilityText(Accessibility accessibility) => accessibility switch
    {
        Accessibility.Public => "public",
        Accessibility.Protected => "protected",
        Accessibility.Private => "private",
        Accessibility.Internal => "internal",
        Accessibility.ProtectedOrInternal => "protected internal",
        Accessibility.ProtectedAndInternal => "private protected",
        _ => throw new InvalidOperationException(),
    };
}
